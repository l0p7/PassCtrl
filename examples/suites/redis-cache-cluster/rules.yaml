endpoints:
  cached-api:
    description: "Relies on Redis-backed caches to reuse profile lookups."
    authentication:
      required: true
      allow:
        authorization: ["bearer"]
      challenge:
        type: bearer
        realm: "External"
    forwardRequestPolicy:
      headers:
        allow: ["authorization", "x-request-id"]
        strip: []
        custom:
          x-user-segment: "external"
      query:
        allow: ["trace"]
        strip: []
        custom: {}
    rules:
      - name: fetch-profile
      - name: check-tier
    responsePolicy:
      pass:
        status: 200
        bodyFile: "pass.json.tmpl"
      fail:
        status: 403
        body: |
          {
            "error": "tier restriction",
            "reason": "{{ .rule.reason }}"
          }
    cache:
      resultTTL: "120s"

rules:
  fetch-profile:
    description: "Calls the profile service and caches pass/fail decisions separately."
    backendApi:
      url: "https://profile.internal/v2/profile"
      method: GET
      headers:
        allow: []
        strip: []
        custom:
          authorization: "Bearer {{ .auth.input.token }}"
      acceptedStatuses: [200, 404]
    conditions:
      pass:
        - lookup(backend.body, "active") == true
      fail:
        - lookup(backend.body, "active") == false
        - backend.status == 404
    variables:
      global:
        user_id:
          from: backend.body.id
        plan:
          from: backend.body.plan
    cache:
      followCacheControl: true
      passTTL: "5m"
      failTTL: "45s"

  check-tier:
    description: "Requires a paid subscription level before allowing access."
    conditions:
      pass:
        - lookup(vars.global, "plan") in ["plus", "enterprise"]
      fail:
        - lookup(vars.global, "plan") == "free"
    responses:
      fail:
        headers:
          custom:
            X-PassCtrl-Plan: "{{ index .vars.global \"plan\" }}"
    cache:
      passTTL: "0s"
      failTTL: "0s"
