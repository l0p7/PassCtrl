# Multi-Credential Composition Example
#
# This example demonstrates the new match-group auth model features:
# - Compound admission requirements (multiple credentials required simultaneously)
# - Multi-format credential emission (same credential as bearer + header + query)
# - Value-based matching with regex patterns
# - Credential composition from multiple sources
#
# Use cases:
# - Heterogeneous client authentication (basic/bearer/header clients â†’ single backend)
# - Token pattern routing (admin vs service vs user tokens)
# - Credential composition (building basic auth from bearer + username header)
# - Service account allowlists

endpoints:
  # Example 1: Heterogeneous client auth with pattern-based routing
  admin-api:
    description: "Admin API accepting multiple auth types with token pattern routing"
    authentication:
      required: true
      allow:
        authorization: ["basic", "bearer"]
        header: ["X-Api-Token"]
    forwardRequest:
      headers:
        allow: ["content-type", "accept"]
      query:
        allow: []
    response:
      pass:
        status: 200
      fail:
        status: 401
        headers:
          custom:
            WWW-Authenticate: 'Bearer realm="admin-api"'
    rules:
      - admin-credential-router

  # Example 2: Compose basic auth from multiple credential sources
  legacy-service:
    description: "Legacy service requiring basic auth composed from modern credentials"
    authentication:
      required: true
      allow:
        authorization: ["bearer"]
        header: ["X-Username"]
    forwardRequest:
      headers:
        allow: ["content-type"]
    response:
      pass:
        status: 200
      fail:
        status: 403
    rules:
      - compose-basic-from-bearer-and-header

  # Example 3: Multi-format credential emission
  multi-backend:
    description: "Emit credentials in multiple formats simultaneously"
    authentication:
      required: true
      allow:
        header: ["PRIVATE-TOKEN"]
    forwardRequest:
      headers:
        allow: ["*"]
      query:
        allow: ["*"]
    response:
      pass:
        status: 200
    rules:
      - emit-multi-format-credentials

rules:
  # Rule 1: Pattern-based routing with admin token matching
  admin-credential-router:
    description: "Route admin tokens differently from service/user tokens"
    auth:
      # Match admin bearer tokens (starting with "admin-")
      - match:
          - type: bearer
            value: "/^admin-/"  # Regex pattern for admin tokens
        forwardAs:
          - type: bearer
            token: "ADMIN-{{ .auth.input.bearer.token }}"
          - type: header
            name: X-Auth-Role
            value: "admin"

      # Match service bearer tokens (starting with "service-")
      - match:
          - type: bearer
            value: "/^service-/"
        forwardAs:
          - type: bearer
            token: "SERVICE-{{ .auth.input.bearer.token }}"
          - type: header
            name: X-Auth-Role
            value: "service"

      # Match basic auth (literal username allowlist)
      - match:
          - type: basic
            username: ["admin", "superuser", "root"]
        forwardAs:
          - type: basic  # Pass through as-is
            user: "{{ .auth.input.basic.user }}"
            password: "{{ .auth.input.basic.password }}"
          - type: header
            name: X-Auth-Role
            value: "admin"

      # Match API token header with pattern
      - match:
          - type: header
            name: X-Api-Token
            value: "/^[A-Za-z0-9]{32,}$/"  # At least 32 alphanumeric chars
        forwardAs:
          - type: bearer
            token: "{{ index .auth.input.header \"x-api-token\" }}"

    backendApi:
      url: "https://admin-backend.example/verify"
      method: POST
      headers:
        custom:
          Content-Type: "application/json"
      body: '{"endpoint": "admin-api"}'
      acceptedStatuses: [200]

    conditions:
      pass:
        - 'backend.status == 200'

  # Rule 2: Compound admission - require BOTH bearer token AND username header
  compose-basic-from-bearer-and-header:
    description: "Compose basic auth from bearer token + username header"
    auth:
      # Require both bearer token AND username header (AND logic within group)
      - match:
          - type: bearer
          - type: header
            name: X-Username
        forwardAs:
          - type: basic
            user: "{{ index .auth.input.header \"x-username\" }}"
            password: "{{ .auth.input.bearer.token }}"

    backendApi:
      url: "https://legacy-backend.example/service"
      method: GET
      acceptedStatuses: [200, 201]

    conditions:
      pass:
        - 'backend.status >= 200 && backend.status < 300'

  # Rule 3: Multi-format emission - emit same credential in multiple formats
  emit-multi-format-credentials:
    description: "Emit credentials as bearer + custom header + query param"
    auth:
      - match:
          - type: header
            name: PRIVATE-TOKEN
        forwardAs:
          # Emit as bearer token
          - type: bearer
            token: "{{ index .auth.input.header \"private-token\" }}"
          # AND as custom header
          - type: header
            name: X-Api-Key
            value: "{{ index .auth.input.header \"private-token\" }}"
          # AND as query parameter
          - type: query
            name: api_key
            value: "{{ index .auth.input.header \"private-token\" }}"

    backendApi:
      url: "https://multi-backend.example/api"
      method: GET
      acceptedStatuses: [200]

    conditions:
      pass:
        - 'backend.status == 200'

# Value Constraint Pattern Examples:
#
# Literal string match:
#   value: "exact-token-value"
#
# Regex pattern:
#   value: "/^admin-[0-9]+$/"
#
# Multiple patterns (OR logic):
#   value: ["literal-token", "/^pattern1-/", "/pattern2-[0-9]+$/"]
#
# Basic auth username/password patterns:
#   username: ["user1", "user2", "/^service-/"]
#   password: "/^[A-Za-z0-9]{16,}$/"
#
# Case-insensitive regex:
#   value: "/(?i)^bearer-/"
