# Multi-endpoint configuration illustrating cache usage, trusted proxies, and
# endpoint selection hints. The example aligns with the staged documentation
# for endpoint and rule configuration.
server:
  listen:
    address: "0.0.0.0"
    port: 8080
  logging:
    level: info
    format: json
  rules:
    rulesFolder: ""
    rulesFile: ""

endpoints:
  shared-default:
    description: "Default endpoint for browser traffic with cached rule outcomes."
    authentication:
      required: false
      allow:
        authorization: ["bearer"]
        header: ["x-session-token"]
    forwardRequestPolicy:
      forwardProxyHeaders: false
    rules:
      - name: session-lookup
      - name: enforce-customer-tier
    responsePolicy:
      pass:
        status: 200
      fail:
        status: 403
        headers:
          X-PassCtrl-Tier: "{{ .response.customer_tier }}"
        body: |
          {
            "error": "access denied"
          }
      error:
        status: 502
        body: |
          {
            "error": "session lookup unavailable"
          }
    cache:
      resultTTL: "120s"

  admin-audit:
    description: "Privileged path that bypasses caching and requires explicit endpoint selection."
    authentication:
      required: true
      allow:
        authorization: ["bearer"]
      challenge:
        type: bearer
        realm: "Admin"
    forwardProxyPolicy:
      trustedProxyIPs: ["10.10.0.0/16"]
      developmentMode: false
    forwardRequestPolicy:
      forwardProxyHeaders: true
    rules:
      - name: audit-token-check
    responsePolicy:
      pass:
        status: 204
      fail:
        status: 403
    cache:
      resultTTL: "0s"

rules:
  session-lookup:
    description: "Retrieves session state from a cache-friendly backend."
    backendApi:
      url: "https://session.internal/v1/lookup"
      method: GET
      headers:
        x-request-id: null  # Copy from raw request
        x-session-token: null  # Copy from raw request
        x-session-segment: "browser"  # Static value
      query:
        locale: null  # Copy from raw request
      acceptedStatuses: [200]
    conditions:
      pass:
        # Use has() for safe field access
        - has(backend.body.active) && backend.body.active == true
      fail:
        # Explicit failure: session is not active
        - has(backend.body.active) && backend.body.active == false
      error:
        # Server errors and network failures
        - backend.status >= 500
        - backend.status == 0
    variables:
      user_id: backend.body.userId
      tier: backend.body.tier
    responses:
      pass:
        variables:
          user_id: variables.user_id
          tier: variables.tier
    cache:
      followCacheControl: true
      passTTL: "5m"
      failTTL: "30s"

  enforce-customer-tier:
    description: "Denies requests from suspended or free-tier accounts."
    conditions:
      pass:
        # Check if session-lookup rule has exported variables
        - '"session-lookup" in variables.rule'
        - 'lookup(variables.rule["session-lookup"], "tier") in ["gold", "platinum"]'
      fail:
        # Explicit failure: free or suspended tier
        - 'lookup(variables.rule["session-lookup"], "tier") in ["free", "suspended"]'
    responses:
      fail:
        variables:
          customer_tier: "{{ .rules.session-lookup.variables.tier }}"
    cache:
      passTTL: "0s"
      failTTL: "0s"

  audit-token-check:
    description: "Validates admin bearer tokens without caching."
    auth:
      - match:
          - type: bearer
        forwardAs:
          - type: bearer
            token: "{{ .auth.input.bearer.token }}"
    backendApi:
      url: "https://audit.internal/v1/validate"
      method: POST
      forwardProxyHeaders: true  # Forward X-Forwarded-* headers
      headers:
        content-type: "application/json"
        x-request-id: null  # Copy from raw request
        x-admin-endpoint: "true"  # Static value to indicate admin path
      body: |
        {
          "token": "{{ .auth.input.bearer.token }}"
        }
      acceptedStatuses: [200]
    conditions:
      pass:
        # Use has() for safe field access
        - has(backend.body.valid) && backend.body.valid == true
      fail:
        # Explicit failure: token is not valid
        - has(backend.body.valid) && backend.body.valid == false
      error:
        # Server errors and network failures
        - backend.status >= 500
        - backend.status == 0
    cache:
      passTTL: "0s"
      failTTL: "0s"
