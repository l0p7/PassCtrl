# Multi-endpoint configuration illustrating cache usage and endpoint selection hints.
server:
  listen:
    address: "0.0.0.0"
    port: 8080
  logging:
    level: info
    format: json
  rules:
    rulesFolder: ""
    rulesFile: ""
  cache:
    backend: memory
    ttlSeconds: 300
    keySalt: "shared-salt"
    epoch: 1

endpoints:
  shared-default:
    description: "Default endpoint for browser traffic with cached rule outcomes."
    authentication:
      required: false
      allow: ["bearer", "header"]
      header: ["x-session-token"]
    forwardRequestPolicy:
      headers:
        allow: ["x-request-id", "x-session-token"]
        strip: []
        custom:
          x-authenticated-user: "{{ .rule.outputs.user_id }}"
      query:
        allow: ["locale"]
        strip: ["debug"]
        custom: {}
    rules:
      - name: session-lookup
      - name: enforce-customer-tier
    responsePolicy:
      pass:
        status: 200
      fail:
        status: 403
    cache:
      resultTTL: "120s"

  admin-audit:
    description: "Privileged path that bypasses caching and requires explicit endpoint selection."
    authentication:
      required: true
      allow: ["bearer"]
      challenge: "Bearer realm=\"Admin\""
    forwardProxyPolicy:
      trustedProxyIPs: ["10.10.0.0/16"]
      developmentMode: false
    forwardRequestPolicy:
      forwardProxyHeaders: true
      headers:
        allow: ["x-request-id", "x-forwarded-for", "x-forwarded-proto"]
        strip: []
        custom:
          x-admin-session: "{{ .auth.input.token }}"
      query:
        allow: []
        strip: []
        custom: {}
    rules:
      - name: audit-token-check
    responsePolicy:
      pass:
        status: 204
      fail:
        status: 403
    cache:
      resultTTL: "0s"

rules:
  session-lookup:
    description: "Retrieves session state from a cache-friendly backend."
    backendApi:
      url: "https://session.internal/v1/lookup"
      method: GET
      headers:
        allow: ["x-session-token"]
        strip: []
        custom: {}
      acceptedStatuses: [200]
    conditions:
      pass:
        - lookup(response.body, "active") == true
      fail:
        - lookup(response.body, "active") == false
    variables:
      rule:
        user_id:
          from: "{{ lookup(response.body, \"userId\") }}"
        tier:
          from: "{{ lookup(response.body, \"tier\") }}"
    cache:
      passTTL: "5m"
      failTTL: "30s"

  enforce-customer-tier:
    description: "Denies requests from suspended or free-tier accounts."
    conditions:
      pass:
        - lookup(previousRule.outputs, "tier") in ["gold", "platinum"]
      fail:
        - lookup(previousRule.outputs, "tier") == "free"
    responses:
      fail:
        status: 403
        body: |
          {
            "error": "upgrade required"
          }
    cache:
      resultTTL: "0s"

  audit-token-check:
    description: "Validates admin bearer tokens without caching."
    backendApi:
      url: "https://audit.internal/v1/validate"
      method: POST
      headers:
        allow: []
        strip: []
        custom:
          authorization: "Bearer {{ .auth.input.token }}"
          content-type: "application/json"
      body: |
        {
          "token": "{{ .auth.input.token }}"
        }
      acceptedStatuses: [200]
    conditions:
      pass:
        - lookup(response.body, "valid") == true
      fail:
        - lookup(response.body, "valid") != true
    cache:
      resultTTL: "0s"
